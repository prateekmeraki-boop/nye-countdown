<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warp Shader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    anvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        if (!gl) {
            console.error('WebGL not supported');
            document.body.innerHTML = '<div style="color: white; text-align: center; padding-top: 50%;">WebGL not supported</div>';
        } else {
            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Vertex shader
            const vertexShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 position;
            
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }`;

            // Fragment shader - Warp/Lava effect
            const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            uniform float time;
            uniform vec2 resolution;
            
            out vec4 FragColor;
            
            // Noise function
            float noise(vec2 p) {
                return sin(p.x * 12.9898 + p.y * 78.233) * 43758.5453;
            }
            
            vec2 warp(vec2 p, float time) {
                return p + vec2(
                    sin(p.y * 3.0 + time) * 0.1,
                    sin(p.x * 3.0 + time) * 0.1
                );
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution;
                
                // Apply warp
                vec2 warped = warp(uv, time);
                
                // Create flowing waves
                float wave1 = sin(warped.x * 3.0 + time * 0.5) * 0.5 + 0.5;
                float wave2 = sin(warped.y * 3.0 + time * 0.3) * 0.5 + 0.5;
                float wave3 = sin((warped.x + warped.y) * 2.0 + time * 0.4) * 0.5 + 0.5;
                
                // Mix waves for a lava-like effect
                vec3 color = mix(
                    vec3(0.1, 0.5, 0.7),  // Teal/Cyan
                    vec3(0.0, 0.8, 0.9),  // Bright cyan
                    (wave1 + wave2 + wave3) / 3.0
                );
                
                // Add some variation
                color += vec3(0.1) * sin(warped * 5.0 + time).xyz;
                
                FragColor = vec4(color, 1.0);
            }`;

            // Compile shader
            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

            // Create program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
            }

            gl.useProgram(program);

            // Create buffer
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, 1
            ]), gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            const timeLocation = gl.getUniformLocation(program, 'time');
            const resolutionLocation = gl.getUniformLocation(program, 'resolution');

            // Render loop
            function render(time) {
                gl.uniform1f(timeLocation, time * 0.001);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                requestAnimationFrame(render);
            }

            render(0);
        }
    </script>
</body>
</html>
